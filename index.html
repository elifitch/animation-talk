<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<link rel="stylesheet" href="css/theme/pres.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<!-- <div class="animated-gradient"></div> -->
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Beyond Keyframes</h1>
					<h3>Modern web animation techniques</h3>
				</section>

				<section>
					<h1>So, who is this guy?</h1>
					<h3 class="emojicon fragment">¯\(º_o)/¯</h3>
				</section>

				<section>
					<h1>Hi, I'm Eli</h1>
					<h3 class="fragment grow">@elifitch</h3>
				</section>

				<section data-background="img/earth-large.jpg" class="work">
					<h1 class="pull-right fragment fade-out">I work here.</h1>
					<!-- picture of earth with isl and arrow appearing on second click -->
					<svg class="fragment isl-arrow" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 3564 2005" enable-background="new 0 0 3564 2005" xml:space="preserve">
						<polygon fill="#00FBE6" points="3509,1740 3078,1740 2994,1660.1 2994,1397.8 3347.3,1397.9 3509,1554.9 "/>
						<g>
							<polygon points="3056,1458 3119,1458 3119,1680.7 3056,1618.2 	"/>
							<polygon points="3310,1458.3 3373,1520 3373,1618 3447,1618 3447,1680 3310,1680 	"/>
							<path d="M3186.3,1458c-40.3,0-61.3,20.7-61.3,61c0,0.5,0,1,0,1h59.2h104.3h17.5v-62C3306,1458,3197.1,1458,3186.3,1458z"/>
							<g>
								<path d="M3186.6,1599c6.6,0,59.4,0,59.4,0v12h60c0-7,0-9.5,0-11.4c0-40.3-18.7-62.6-59-62.6c-8.9,0-64,0-64,0v-10h-58
									c0,5,0,8.4,0,12.1C3125,1579.4,3146.3,1599,3186.6,1599z"/>
								<path d="M3125,1618v62c0,0,91.1,0,122,0c40,0,59-20,59-60.2c0-0.6,0-1.8,0-1.8H3125z"/>
							</g>
						</g>
						<path class="isl-arrow__arrow" fill="none" stroke="#FFFFFF" stroke-width="4" stroke-dasharray="5000" stroke-miterlimit="10" d="M3018,1765c0,0-489.6,410.3-905.6-253.7
							c0,0,64,1,162,54.5l-134,97.5c0,0-17.3-109.2-17.3-146">
							<!-- <animate attributeType="XML" attributeName="stroke-dashoffset" from="5000" to="0" dur="10s" repeatCount="1" fill="freeze"/> -->
						</path>
	 				</svg>
				</section>

				<section class="particle" data-background="#F5F5F5">
					<h1>And I do a lot of 
					<span class="fragment" style="display: block;">front end development,</span>
					<span class="fragment" style="display: block;">animation,</span>
					<span class="fragment" style="display: block;">and...whatever this is.</span>
					</h1>
				</section>

				<section>
					<h1>I'll be shreiking about</h1>
					<h2 class="fragment">How to betterify your CSS animations</h2>
					<h2 class="fragment">How the browser makes all your pretty pixels</h2>
					<h2 class="fragment">When JS animation makes sense</h2>
					<h2 class="fragment">How JS improves workflow & opens possibilites</h2>
					<aside class="notes">
						Performance
						CSS animation techniques in terms of properties
						Browser rendering steps
						JS lets you do more stuff
						Jankfree JS
						Request animation frame

						animation libraries for performance and workflow - This isn't going to be super pracitcal "this is how you use this neat library" type stuff, there's lots of information out there on the interwebs for that, I'm going to focus more on when and why they should be considered, and relative strengths/weaknesses
					</aside>
				</section>

				<section>
					<h1>CSS is great for <span class="fragment shrink" style="display: inline-block">small</span> state changes</h1>
					<aside class="notes">
						This applies to most interactions, really.
						Think changing the background on a ghost button, animating a button press to give the sense of 3d.
						CSS makse such small changes really easy and quick to whip up, making carelessness easy too.
						Using javascript to manage states is cool, but you can store your animations in a class and transition between them, CSS is driving that anim

						Most people have a good handle on this and just throw them in there willy nilly without regard for performance
					</aside>
				</section>

				<section class="properties">
					<h1>CSS properties are not created equal.</h1>
					<span class="fragment js-build-left current-visible"></span>
					<div class="fragment left-container current-visible"></div>
					<span class="fragment js-destroy-left current-visible"></span>

					<span class="fragment js-build-trans current-visible"></span>
					<div class="fragment translate-container current-visible"></div>
					<span class="fragment js-destroy-trans current-visible"></span>
					
					<!-- <div class="translate"></div> -->
					<aside class="notes">
						Note how they're different and say, this is due to how the browser renders things, move on to browser rendering steps, come back to this later
					</aside>
				</section>

				<section>
					<h1>Performance is<br><span class="fragment">fucking</span><br>important</h1>
					
					<!-- <div class="translate"></div> -->
					<aside class="notes">
						This doesn't make sense here....
						Talk about the facebook study
					</aside>
				</section>

				<section>
					<h1>Browser rendering steps</h1>
					<h2 class="fragment">Layout</h2>
					<h2 class="fragment">Paint</h2>
					<h2 class="fragment">Composite</h2>

					<aside class="notes">
						Describe layering, composting, painting.
						Layout is figuring out where everything is on the screen and how big it is.

						Avoid layout: layout is really really fucking expensive
						Also if you're changing heights, widths etc can change the position of other elements it causes more layout changes and more and more and more and OH GOD
					</aside>
				</section>

				<section>
					<h1>Why layout is expensive</h1>
					<div class="fragment" style="display: inline-block; width: 40%; margin-right: 5%; text-align: left; vertical-align: top">
						<h3>Height</h3>
						<hr>
						<img src="img/layout-paint-composite.png" style="max-height: 500px"/>
					</div>

					<div class="fragment" style="display: inline-block; width: 40%; margin-right: 5%; text-align: left; vertical-align: top">
						<h3>Transform</h3>
						<hr>
						<img src="img/just-composite.png" style="max-height: 500px"/>
					</div>

					<aside class="notes">
						Describe this process
					</aside>
				</section>

				<section>
					<h1>Paint is expensive too</h1>
					
					<img class="fragment" src="img/paint-time.png" />

					<aside class="notes">
						Describe this process

						Depends on size of paint area: ie fixed backgrounds cause janky scroll
					</aside>
				</section>

				<section class="properties">
					<h1>Lets cheat.</h1>
					<span class="fragment js-build-left current-visible"></span>
					<div class="fragment left-container current-visible"></div>
					<span class="fragment js-destroy-left current-visible"></span>

					<span class="fragment js-build-trans current-visible"></span>
					<div class="fragment translate-container current-visible"></div>
					<span class="fragment js-destroy-trans current-visible"></span>
					
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1>TLDR</h1>
					<div class="fragment" style="display: inline-block; width: 25%; margin-right: 10%; text-align: left">
						<h3>Layout</h3>
						<hr>
						<p>width/height</p>
						<p>top/right/bottom/left</p>
						<p>padding</p>
						<p>font-size</p>
					</div>
					<div class="fragment" style="display: inline-block; width: 25%; margin-right: 10%; text-align: left">
						<h3>Paint</h3>
						<hr>
						<p>color</p>
						<p>background</p>
						<p>box-shadow</p>
						<p>border-radius</p>
					</div>
					<div class="fragment" style="display: inline-block; width: 25%; text-align: left">
						<h3>Composite</h3>
						<hr>
						<p>opacity</p>
						<p>scale</p>
						<p>rotate</p>
						<p>translate</p>
					</div>
					
					<aside class="notes"></aside>
				</section>

				<section class="properties">
					<h1>Test baby test</h1>
					<h2 class="fragment">Paint areas</h2>
					<h2 class="fragment">Layer borders</h2>
					<h2 class="fragment">Scroll bottlenecks</h2>
					<h2 class="fragment">FPS</h2>
					
					<aside class="notes">
						Layers aren't free, layers aren't a magic bullet.  They break sticky elements for example, b/c they fix relative to the layer, not relative to the viewport.

						Gotta test.

						If you wait too long to start testing render performance you're totally fucked.  Work with designers to make sure the cool stuff you guys dream up doesn't kerplode everything in a fireball of shit.
					</aside>
				</section>


				<!-- <section>
					<h1>TLDR:</h1>
					<h3 class="fragment" style="text-align: left">opacity/transforms > height/width/background/etc</h3>
					<h3 class="fragment" style="text-align: left">Try not to repaint huge areas</h3>
					<h3 class="fragment" style="text-align: left">Batch reads and writes together</h3>
					
					<aside class="notes">
						Evaluate how much of the screen will get relayed out or repainted. If you have a fixed background on the page, when you scroll the browser has to continually repaint because elements are changing relative to the fixed background behind them.

						Avoid running a shitton of layout operations like duh. If you're doing a loop where you have to read styles, store it in a var beforehand so you wont continually ask the browser to read the size of an element
					</aside>
				</section> -->

				<section>
					<h1>Why not use CSS to animate everything?</h1>
					<h2 class="fragment">It can be a little limiting.</h2>
					<h2 class="fragment">When you get crazy, so does your workflow</h2>
					
					<aside class="notes">
						I know which properties give the most performance now, I can optimize my CSS animations, why not use for everything.
					</aside>
				</section>

				<section data-background="https://gimmebar-assets.s3.amazonaws.com/4f4fe1d47cd85.gif">
					<h1>JS gives you the power.</h1>
					
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1 class="js-ind-trans-target">Independent transforms</h1>
					<span class="js-ind-trans-trigger fragment"></span>
					<!-- <iframe id="cp_embed_5617a718d5abb68caae7c0600236e7b1" src="//codepen.io/GreenSock/embed/5617a718d5abb68caae7c0600236e7b1?height=500&amp;theme-id=1&amp;slug-hash=5617a718d5abb68caae7c0600236e7b1&amp;user=GreenSock&amp;default-tab=result&amp;animations=run" scrolling="no" frameborder="0" height="500" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe> -->
				</section>

				<section>
					<h1 class="js-boing-target">Complex easing (physics!)</h1>
					<span class="js-boing-trigger fragment"></span>
					<!-- <iframe id="cp_embed_hyeDg" src="//codepen.io/julianshapiro/embed/hyeDg?height=500&amp;theme-id=8287&amp;slug-hash=hyeDg&amp;default-tab=result&amp;user=julianshapiro" scrolling="no" frameborder="0" height="500" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe> -->
				</section>

				<section>
					<h1>Animating weird stuff</h1>
					<span class="js-show-gradient fragment"></span>
					<span class="js-remove-gradient fragment"></span>
				</section>

				<section>
					<h1 class="fragment js-anim-curve-trigger">Animating along a bezier <span class="js-anim-curve-target" style="display: inline-block">curve</span></h1>
					
				</section>

				<section>
					<h1 class="fragment js-random-anim current-visible stack__item">Randomized animation</h1>
				</section>
				<section>
					<h1 class="fragment">IE8 support! <span class="fragment">hahaha </span><span class="fragment">hah </span><span class="fragment">haa... </span><span class="fragment">but seriously.</span></h1>
					<h1 class="fragment">It's important<span class="fragment">..?</span></h1>
				</section>
				

				<section>
					<h1 class="fragment">Wait, isn't JS animation slow?</h1>
					
					<aside class="notes">
						
					</aside>
				</section>

				<section data-background="img/myth-busters.gif">
					<h1>Myth Busting Time.</h1>
					<div class="stack">
						<h1 class="stack__item fragment current-visible">JS !== janky</h1>
						<h1 class="stack__item fragment current-visible">jQuery $.animate is the devil.</h1>
					</div>
					
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1>setInterval vs. requestAnimationFrame</h1>
					<!-- <img class="fragment" src="img/setinterval.png"/> -->
					<iframe src="http://www.html5rocks.com/en/tutorials/speed/rendering/raf-motivation.html" style="width: 100%; height: 280px; background-color: white"></iframe>
					<aside class="notes">
						With RAF "The browser can optimize concurrent animations together into a single reflow and repaint cycle, leading to higher fidelity animation. For example, JS-based animations synchronized with CSS transitions or SVG SMIL." Also Animations in inactive tabs will stop, allowing the CPU to chill. It's also synced with refresh rate so you won't drop frames
					</aside>
				</section>

				<section>
					<h1>RAF isn't scary</h1>
					<div class="stack">
						<pre class="stack__item">
							<code class="javascript fragment">
var opacity = 0;

// runs every 17ms to try to achieve 60fps (1000ms/60 ~= 17ms).
var fadeIn = setInterval(function() {
	if(opacity < 1) {
		element.style.opacity = (opacity += 0.05);
	} else {
		clearInterval(fadeIn)
	}
}, 17);
							</code>
						</pre>

						<pre class="stack__item">
							<code class="javascript fragment">
// requestAnimationFrame: Attempts to run at 60fps based on
// whether the browser is in an optimal state.
var opacity = 0;

var fadeIn = function() {
       if(opacity < 1){
         window.requestAnimationFrame(fadeIn);
         element.style.opacity = (opacity += 0.05);
       }
}

fadeIn();
							</code>
						</pre>
						<!-- <pre>
							<code>
var elem = document.getElementById('my-element'),
  startTime = null,
  endPos = 500, // in pixels
  duration = 2000; // in milliseconds
 
function render(time) {
  if (time === undefined) {
    time = new Date().getTime();
  }
  if (startTime === null) {
    startTime = time;
  }
  if((time-startTime) <= duration) {
    elem.style.left = ((time - startTime) / duration * endPos % endPos) + 'px';   
  }
}
							</code>
						</pre> -->
					</div>
					
						

					<aside class="notes">
						You can also get a start time and continue the animation until a certain amount of progress has happened if you want to have time based animations, or wrap it in a settimeout with the timing set as 1000/desiredFramerate
						If there's just one "complex" anim in a project (simple button hovers and shit but one rotating gradient), just roll your own JS animation
						However, if you have more than a handful of these, really really consider using a library.
					</aside>
				</section>

				<section>
					<h1>Performance is more than properties</h1>
					
					<aside class="notes">
						be mindful of layout in JS too, CSS often triggered by JS
					</aside>
				</section>

				<section>
					<h1>Don't thrash</h1>
					<div class="stack">
						<pre class="stack__item">
							<code class="javascript fragment">
var h1 = element1.clientHeight;           // Read (measures the element)
element1.style.height = (h1 * 2) + 'px';  // Write (invalidates current layout)

var h2 = element2.clientHeight;           // Read (measure again, so must trigger layout)
element2.style.height = (h1 * 2) + 'px';  // Write (invalidates current layout)

var h3 = element3.clientHeight;           // Read (measure again, so must trigger layout)
element3.style.height = (h3 * 2) + 'px';  // Write (invalidates current layout)
							</code>
						</pre>

						<pre class="stack__item">
							<code class="javascript fragment">
// Readenzie
var h1 = element1.clientHeight; 
var h2 = element2.clientHeight; 
var h3 = element3.clientHeight; 

// Writenzie
element1.style.height = (h1 * 2) + 'px';
element2.style.height = (h1 * 2) + 'px';
element3.style.height = (h3 * 2) + 'px';
							</code>
						</pre>
					</div>
					<aside class="notes">
						Credit Wilson Page http://wilsonpage.co.uk/preventing-layout-thrashing/
						be mindful of layout in JS too, CSS often triggered by JS

						Problem is, nobody actually writes code this way. Segue into workflow/library shit?
						You can use something like fastdom, or a dedicated anim library that includes batching as a performance enhancer
					</aside>
				</section>

				<!-- <section>
					<h1>Cache = $$$</h1>
					<div class="stack">
						<pre class="stack__item">
							<code class="javascript fragment">
for(var i = 0; i < $('.herp').length; i++) {
	$('.herp').index(i).css('background','rgb(0,'+i*5+',0,)');
	$('.derp').index(i).text('this is derp number '+i+1)
}
							</code>
						</pre>

						<pre class="stack__item">
							<code class="javascript fragment">
var $herp = $('.herp');
var $derp = $('.derp');
for(var i = 0, l = $herp.length; i < l; i++) {
	$herp.index(i).css('background','rgb(0,'+i*5+',0,)');
	$derp.index(i).text('this is derp number '+i+1)
}
							</code>
						</pre>
					</div>
					<aside class="notes">
						This is a basic JS thing you can do to make code mor efficient
						the performance gains from caching increase as the loops iterations increase
					</aside>
				</section> -->

				<section>
					<h1>Bind events as close as possible</h1>
					
					<aside class="notes">
						Especially important with touch or scroll listeners.
						Basically if you do 
						https://www.youtube.com/watch?v=YyQYhhy1dZI  ~23:00
					</aside>
				</section>

				<section>
					<h1>Debounce</h1>
					<div class="stack">
						<pre>
							<code class="javascript" style="min-height: 28em;">
var debounce = function(func, wait, immediate) {
  var timeout, result;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) result = func.apply(context, args);
    return result;
  };
};

window.addEventListener('scroll', function(){
	debounce(function(){
		//cool animation
	},100)
},false)
							</code>
						</pre>
					</div>
					<aside class="notes">
						Debouncing is a fancy pants way to say limit a function from firing too many damn times.
						Especially important when binding to resize or scroll.
						Why fire a function more times than the browser can even refresh?

						This belongs in JS section
					</aside>
				</section>

				<section>
					<h1>Lets talk workflow</h1>
					<pre class="fragment">
						<code class="css" style="min-height: 23em;">
.logo {
	animation: myAnimation 2s linear forwards;
}
@keyframes myAnimation {
  0% {
    opacity: 0;
    transform: scale(0, 0);
  }
  25% {
    opacity: 1;
    transform: scale(1, 1);
  }
  50% {
    transform: translate(0px, 0);
  }
  100% {
    transform: translate(100px, 0);
  }
}
						</code>
					</pre>

					<p class="fragment">So what happens when somebody wants the translate to take an extra 400ms?</p>
					
					<!-- <div class="translate"></div> -->
					<aside class="notes"></aside>
				</section>

				<section data-background="img/blinds.gif">
					<h2 class="fragment">This, basically.</h2>
					<aside class="notes">
						Managing CSS keyframes, especially when they get complex, can be hard, it can be time consuming.
						Impedes experimentation.
						And in the end, when you want to get creative, CSS animation is limiting(no independent transforms, different steps with different easing etc)
					</aside>
				</section>

				<section>
					<h1>Lib your life.</h1>
					<div class="stack">
					<pre class="stack__item fragment" style="font-size: .45em">
						<code class="css">
.logo {
	animation: myAnimation 2s linear forwards;
}
@keyframes myAnimation {
  0% {
    opacity: 0;
    transform: scale(0, 0);
  }
  25% {
    opacity: 1;
    transform: scale(1, 1);
  }
  50% {
    transform: translate(0px, 0);
  }
  100% {
    transform: translate(100px, 0);
  }
}
						</code>
					</pre>

					<pre class="stack__item fragment" style="font-size: .45em">
						<code class="javascript">
var el = document.getElementsByClassName('logo')

Velocity(el, {
    opacity: [1, 0],
    scale:[1, 0]
  },{
    duration:500,
    easing: "linear"
  }
);
Velocity(el, {
    translateY: '100px'
  },{
    duration:1000,
    delay:500,
    easing: "linear"
  }
);
						</code>
					</pre>

					<pre class="stack__item fragment" style="font-size: .45em">
						<code class="javascript">
var el = document.getElementsByClassName('logo')

TweenLite.fromTo(el, .5, {
    opacity:0,
    scale:0,
    ease:"Linear.easeNone"
  },{
    opacity:1,
    scale:1,
    ease:"Linear.easeNone",
    onComplete: function(){
      TweenLite.to(el, 1, {
        delay:.5,
        y:100,
        ease:"Linear.easeNone"
      });
    }
  }
);
						</code>
					</pre>
					</div><!--end stack-->
					<aside class="notes">
						Libraries make the type of rapid changes and experimentation ESSENTIAL to creating good animations totally trivial.
						Easier than wrangling with keyframes, and yeah, probably easier than rolling your own RAF loops.
						Libraries make for an easier workflow. This is SO important.
					</aside>
				</section>

				<section>
					<h1>Another example</h1>
					<div class="stack">
					<pre class="stack__item fragment current-visible">
						<code class="css">
//independent transforms example
var target = document.getElementsByClassName('.js-ind-trans-target')[0];
var rotation = 0;

TweenMax.to(target,1.2, {scale:1.2, force3D:true, yoyo:true, repeat:-1, ease:Power1.easeInOut});

target.on('click',function(){
	rotation += 360;
	TweenMax.to(target, 2, {rotation: rotation, ease:Elastic.easeOut})
});
						</code>
					</pre>

					<pre class="stack__item fragment current-visible">
						<code class="javascript">
//physics example
var target = $('.js-boing-target');
target.on('click',function(){
	target.velocity({translateY: -200},600,[500,15]).velocity("reverse")
})
						</code>
					</pre>

					</div><!--end stack-->
					<aside class="notes">
						Libraries make the type of rapid changes and experimentation ESSENTIAL to creating good animations totally trivial.
						Easier than wrangling with keyframes, and yeah, probably easier than rolling your own RAF loops.
						Libraries make for an easier workflow. This is SO important.
					</aside>
				</section>

				<section>
					<h1>Other nice-to-haves</h1>
					<h3 class="fragment">Reverse / yoyo</h3>
					<h3 class="fragment">TweenLite.from</h3>
					<h3 class="fragment">Sequencing</h3>
					<h3 class="fragment">Granular control</h3>
					<aside class="notes">
						BREAK INTO SLIDES
					</aside>
				</section>

				<section>
					<h1 class="fragment fade-out">Workflow is important</h1>
					<h1 class="fragment">Easier changes</h1>
					<h1 class="fragment">More experimentation</h1>
					<h1 class="fragment">Better work</h1>
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1>Performance</h1>
					<h3 class="fragment">Global timing loop for all animations</h3>
					<h3 class="fragment">Minimizes layout thrash</h3>
					<h3 class="fragment">Cache conversions</h3>
					<aside class="notes">
						Timer optimization fixes 2 issues:
						1) too many timers firing at once reduces frame rates due to the browser’s overhead of maintaining them, and 2) improperly marking the time at which your animation begins results in dropped frames (usually you have the animation start when you click the button, but due to a myriad of factors like CPU overhead, other JS logic at the same time, etc) can cause a delay in when you start to see the anim, dropping early frames.

						Caching property values across chained calls in order to minimize the occurrence of DOM querying (which is the Achilles' heel of performant DOM animation).
						Caching unit conversion ratios (e.g. px to %, em, etc.) across sibling elements in the same call.
						Skipping style updating when updates would be visually imperceptible.

						You could write these optimizations into your own hand crafted animation code, but then A. your code becomes harder to manage, and B. you end up creating an animation library yourself.
					</aside>
				</section>

				<section>
					<h1>Another dependency</h1>
					<h1 class="fragment">le UGH!</h1>
					<aside class="notes">
						Velocity ~35kb
						TweenLite & CSSPlugin ~60kb
					</aside>
				</section>

				<section>
					<h1>Don't be a stupid.</h1>
					<h1 class="fragment">Weigh the costs and benefits.</h1>
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1>le OMG I love libraries</h1>
					<h1 class="fragment">Which one is raddest?</h1>
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1>Greensock</h1>
					<h2 class="fragment">Insane timlineing and control</h2>
					<h2 class="fragment">Super simple sequencing</h2>
					<h2 class="fragment">A tad better performance</h2>
					<h2 class="fragment">More options and capabilites</h2>
					<h2 class="fragment">Big KB hit</h2>
					<h2 class="fragment">Licensing</h2>
					<h2 class="fragment">Best when Animations ARE a core of the product</h2>
					<aside class="notes">
						TweenLite & CSSPlugin ~60kb
						Think interactive experiences/infographics/scrollers, canvas art, games
					</aside>
				</section>

				<section>
					<h1>Velocity</h1>
					<h2 class="fragment">UI only</h2>
					<h2 class="fragment">Lighter KB hit</h2>
					<h2 class="fragment">More approachable API</h2>
					<h2 class="fragment">Same syntax as jQuery</h2>
					<h2 class="fragment">100% open source</h2>
					<h2 class="fragment">Plays extra well with promises</h2>
					<aside class="notes">
						TweenLite & CSSPlugin ~60kb
						Promises: http://www.smashingmagazine.com/2014/09/04/animating-without-jquery/
					</aside>
				</section>

				

			</div>

		</div>

		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
		<script src="js/velocity.min.js"></script>
		<script src="js/blast.min.js"></script>
		<!--<script src="js/tweenlite.min.js"></script>
		<script src="js/gsap-css-plugin.min.js"></script>-->
		<script src="js/tweenmax.min.js"></script>


		<script src="js/app.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: false,
				history: true,
				center: true,
				width: 1200,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
