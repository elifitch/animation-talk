<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Beyond Keyframes: Modern web animation techniques</title>

		<meta name="description" content="A non-dogmatic look at the place of CSS in web animation and how you can leverage javascript to easily produce crisp, flexible UI animations.">
		<meta name="author" content="Eli Fitch">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<link rel="stylesheet" href="css/theme/pres.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<!-- <div class="animated-gradient"></div> -->
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Beyond Keyframes</h1>
					<h3>Modern web animation techniques</h3>
				</section>

				<section>
					<h1>So, who is this guy?</h1>
					<h3 class="emojicon">¯\(º_o)/¯</h3>
				</section>

				<section>
					<h1>Hi, I'm Eli</h1>
					<h3 class="fragment grow">@elifitch</h3>
				</section>

				<section data-background="img/earth-large.jpg" class="work">
					<h1 class="pull-right fragment fade-out">I work here.</h1>
					<!-- picture of earth with isl and arrow appearing on second click -->
					<svg class="fragment isl-arrow" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 3564 2005" enable-background="new 0 0 3564 2005" xml:space="preserve">
						<polygon fill="#00FBE6" points="3509,1740 3078,1740 2994,1660.1 2994,1397.8 3347.3,1397.9 3509,1554.9 "/>
						<g>
							<polygon points="3056,1458 3119,1458 3119,1680.7 3056,1618.2 	"/>
							<polygon points="3310,1458.3 3373,1520 3373,1618 3447,1618 3447,1680 3310,1680 	"/>
							<path d="M3186.3,1458c-40.3,0-61.3,20.7-61.3,61c0,0.5,0,1,0,1h59.2h104.3h17.5v-62C3306,1458,3197.1,1458,3186.3,1458z"/>
							<g>
								<path d="M3186.6,1599c6.6,0,59.4,0,59.4,0v12h60c0-7,0-9.5,0-11.4c0-40.3-18.7-62.6-59-62.6c-8.9,0-64,0-64,0v-10h-58
									c0,5,0,8.4,0,12.1C3125,1579.4,3146.3,1599,3186.6,1599z"/>
								<path d="M3125,1618v62c0,0,91.1,0,122,0c40,0,59-20,59-60.2c0-0.6,0-1.8,0-1.8H3125z"/>
							</g>
						</g>
						<path class="isl-arrow__arrow" fill="none" stroke="#FFFFFF" stroke-width="4" stroke-dasharray="5000" stroke-miterlimit="10" d="M3018,1765c0,0-489.6,410.3-905.6-253.7
							c0,0,64,1,162,54.5l-134,97.5c0,0-17.3-109.2-17.3-146">
							<!-- <animate attributeType="XML" attributeName="stroke-dashoffset" from="5000" to="0" dur="10s" repeatCount="1" fill="freeze"/> -->
						</path>
	 				</svg>
	 				<aside class="notes">
						<p>recruiting</p>
					</aside>
				</section>

				<section class="particle" data-background="#F5F5F5">
					<h1>And I do a lot of 
					<span class="fragment" style="display: block;">front end development,</span>
					<span class="fragment" style="display: block;">animation,</span>
					<span class="fragment" style="display: block;">and...whatever this is.</span>
					</h1>
					<aside class="notes">
						<p>Fun, frivolous, experiments like this guy</p>
					</aside>
				</section>

				<section>
					<h1>I'll be shreiking about</h1>
					<h2 class="fragment">How to betterify your CSS animations</h2>
					<h2 class="fragment">How the browser makes all your pretty pixels</h2>
					<h2 class="fragment">When JS animation makes sense</h2>
					<h2 class="fragment">How to write more performant JS animations</h2>
					<h2 class="fragment">How JS animation libraries can help</h2>
					<aside class="notes">
						<p>This isn't going to be super pracitcal "this is how you use this neat library" type stuff, there's lots of information out there on the interwebs for that, I'm going to focus more on when and why they should be considered, and relative strengths/weaknesses</p>
					</aside>
				</section>

				<section>
					<h1>CSS is great for <span class="fragment shrink" style="display: inline-block">small</span> state changes</h1>
					<aside class="notes">
						<p>This applies to most interactions, really.</p>
						<p>Think changing the background on a ghost button, animating a button press to give the sense of 3d.</p>
						<p>CSS makse such small changes really easy and quick to whip up, making carelessness easy too.</p>

						<p>Most people have a good handle on this and just throw them in there willy nilly without regard for performance</p>
					</aside>
				</section>

				<section>
					<h1>Performance is<br><span class="fragment">fucking</span><br>important</h1>
					
					<!-- <div class="translate"></div> -->
					<aside class="notes">
						<p>Talk about the facebook study</p>
						<p>Small % of users, 20-30 million</p>
					</aside>
				</section>

				<section class="properties">
					<h1>CSS properties are not created equal.</h1>
					<span class="fragment js-build-left current-visible"></span>
					<div class="fragment left-container current-visible"></div>
					<span class="fragment js-destroy-left current-visible"></span>

					<span class="fragment js-build-trans current-visible"></span>
					<div class="fragment translate-container current-visible"></div>
					<span class="fragment js-destroy-trans current-visible"></span>
					
					<!-- <div class="translate"></div> -->
					<aside class="notes">
						<p>Hmm these appear to be the same but why is one choppy</p>
						<p>WTAF is goon on here??</p>
					</aside>
				</section>

				<section>
					<h1>Browser rendering steps</h1>
					<h2 class="fragment">Layout</h2>
					<h2 class="fragment">Paint</h2>
					<h2 class="fragment">Composite</h2>

					<aside class="notes">
						Describe layering, composting, painting.
						<p>Layout is figuring out where everything is on the screen and how big it is.</p>

						<p>Layout: Also if you're changing heights, widths etc can change the position of other elements it causes more layout changes and more and more and more and OH GOD</p>
					</aside>
				</section>

				<section>
					<h1>Mind your layout</h1>
					<!-- <div class="fragment" style="display: inline-block; width: 40%; margin-right: 5%; text-align: left; vertical-align: top">
						<h3>Height</h3>
						<hr>
						<img class="img--expandable" src="img/layout-paint-composite.png" style="max-height: 500px"/>
					</div>

					<div class="fragment" style="display: inline-block; width: 40%; margin-right: 5%; text-align: left; vertical-align: top">
						<h3>Transform</h3>
						<hr>
						<img class="img--expandable" src="img/just-composite.png" style="max-height: 500px"/>
					</div> -->

					<aside class="notes">
						<p>Images hard to see but the orange blocks represent browser thinky time</p>
						<p>Blue is GPU doing its thing</p>
						<p>See how one is way easier on the browser than another?</p>
						<p>This is b/c one prop triggers layout while the other does not</p>
					</aside>
				</section>

				<section>
					<h1>Paint is slow</h1>
					
					<img class="fragment" src="img/paint-time.png" />

					<aside class="notes">
						<p>Depends on size of paint area: ie fixed backgrounds cause janky scroll</p>
					</aside>
				</section>

				<section class="properties">
					<h1>Lets cheat.</h1>
					<span class="fragment js-build-left current-visible"></span>
					<div class="fragment left-container current-visible"></div>
					<span class="fragment js-destroy-left current-visible"></span>

					<span class="fragment js-build-trans current-visible"></span>
					<div class="fragment translate-container current-visible"></div>
					<span class="fragment js-destroy-trans current-visible"></span>
					
					<aside class="notes">
						<p>Layers aren't free, layers aren't a magic bullet.  They break sticky elements for example, b/c they fix relative to the layer, not relative to the viewport.</p>
						<p>On older mobile devices, you can run out of GPU memory, and have a severe stutter as a result</p>

					</aside>
				</section>

				<section class="properties">
					<h1>Test baby test</h1>
					<h2 class="fragment">Paint areas</h2>
					<h2 class="fragment">Layer borders</h2>
					<h2 class="fragment">Scroll bottlenecks</h2>
					<h2 class="fragment">FPS</h2>
					
					<aside class="notes">

						Gotta test.

						If you wait too long to start testing render performance you're totally fucked.  Work with designers to make sure the cool stuff you guys dream up doesn't kerplode everything in a fireball of shit.
					</aside>
				</section>

				<section>
					<h1>Property Breakdown</h1>
					<div class="fragment" style="display: inline-block; width: 25%; margin-right: 10%; text-align: left">
						<h3>Layout</h3>
						<hr>
						<p>width/height</p>
						<p>top/right/bottom/left</p>
						<p>padding</p>
						<p>font-size</p>
					</div>
					<div class="fragment" style="display: inline-block; width: 25%; margin-right: 10%; text-align: left">
						<h3>Paint</h3>
						<hr>
						<p>color</p>
						<p>background</p>
						<p>box-shadow</p>
						<p>border-radius</p>
					</div>
					<div class="fragment" style="display: inline-block; width: 25%; text-align: left">
						<h3>Composite</h3>
						<hr>
						<p>opacity</p>
						<p>scale</p>
						<p>rotate</p>
						<p>translate</p>
					</div>
					
					<aside class="notes">
						<p>Avoid layout changes, and if you have to make one, if you can isolate that element, good</p>
						<p>Avoid continually repainting large areas (parallax for example)</p>
						<p>Leverage transforms and opacity in creative ways to make up for other shit</p>
					</aside>
				</section>


				<section>
					<h1>Why not use CSS to animate everything?</h1>
					<h2 class="fragment">It can be a little limiting.</h2>
					<h2 class="fragment">When you get crazy, so does your workflow</h2>
					
					<aside class="notes">
						<p>I know which properties give the most performance now, I can optimize my CSS animations, why not use for everything.</p>
						<p>When you think in terms of what CSS will let you do you will never fulfil your potential</p>
					</aside>
				</section>

				<section data-background="https://gimmebar-assets.s3.amazonaws.com/4f4fe1d47cd85.gif">
					<h1>JS gives you the power.</h1>
					
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1 class="js-ind-trans-target">Independent transforms</h1>
					<span class="js-ind-trans-trigger fragment"></span>
				</section>

				<section>
					<h1 class="js-boing-target">Complex easing (physics!)</h1>
					<span class="js-boing-trigger fragment"></span>
				</section>

				<section>
					<h1>Animating weird stuff</h1>
					<span class="js-show-gradient fragment"></span>
					<span class="js-remove-gradient fragment"></span>
					<aside class="notes">
						<p>This, as we will discuss later, also applies to any javascript object property</p>
						<p>This, as we will discuss later, also applies to any javascript object property</p>
					</aside>
				</section>

				<section>
					<h1 class="fragment js-anim-curve-trigger">Animating along a bezier <span class="js-anim-curve-target" style="display: inline-block">curve</span></h1>
					
				</section>

				<section>
					<h1 class="fragment js-random-anim current-visible stack__item">Randomized animation</h1>
				</section>
				<section>
					<h1 class="fragment">IE8/9 support! <span class="fragment">hahaha </span><span class="fragment">hah </span><span class="fragment">haa... </span><span class="fragment">.......</span></h1>
					<h1 class="fragment">Moving on.</h1>
				</section>
				

				<section>
					<h1 class="fragment">Wait, isn't JS animation slow?</h1>
					
					<aside class="notes">
						<p>Isn't shitty JS anim the whole reason CSS rose to prominence?</p>
					</aside>
				</section>

				<section data-background="img/myth-busters.gif">
					<h1>Myth Busting Time.</h1>
					<div class="stack">
						<h1 class="stack__item fragment current-visible">JS !== janky</h1>
						<h1 class="stack__item fragment current-visible">jQuery $.animate is the devil.</h1>
					</div>
					
					<aside class="notes">
						<p>JS isn't necessarily janky. Poorly WRITTIen JS anims are janky.</p>
						<p>Folks falsly conflate JS and JQ anims</p>
					</aside>
				</section>

				<section>
					<h1>setInterval vs. requestAnimationFrame</h1>
					<!-- <img class="fragment" src="img/setinterval.png"/> -->
					<iframe src="http://www.html5rocks.com/en/tutorials/speed/rendering/raf-motivation.html" style="width: 100%; height: 280px; background-color: white"></iframe>
					<aside class="notes">
						<p>With RAF "The browser can optimize concurrent animations together into a single reflow and repaint cycle</p>
						<p>For example, JS-based animations synchronized with CSS transitions or SVG SMIL.</p>
						<p>Also Animations in inactive tabs will stop, allowing the CPU to chill.</p>
						<p>It's also synced with refresh rate so you won't drop frames</p>
					</aside>
				</section>

				<section>
					<h1>RAF isn't scary</h1>
					<div class="stack">
						<pre class="stack__item">
							<code class="javascript fragment">
var opacity = 0;

// runs every 16ms to try to achieve 60fps (1000ms/60 ~= 16ms).
var fadeIn = setInterval(function() {
	if(opacity < 1) {
		element.style.opacity = (opacity += 0.05);
	} else {
		clearInterval(fadeIn)
	}
}, 16);
							</code>
						</pre>

						<pre class="stack__item">
							<code class="javascript fragment">
// requestAnimationFrame: Attempts to run at 60fps based on
// whether the browser is in an optimal state.
var opacity = 0;

var fadeIn = function() {
       if(opacity < 1){
         window.requestAnimationFrame(fadeIn);
         element.style.opacity = (opacity += 0.05);
       }
}

fadeIn();
							</code>
						</pre>
						<!-- <pre>
							<code>
var elem = document.getElementById('my-element'),
  startTime = null,
  endPos = 500, // in pixels
  duration = 2000; // in milliseconds
 
function render(time) {
  if (time === undefined) {
    time = new Date().getTime();
  }
  if (startTime === null) {
    startTime = time;
  }
  if((time-startTime) <= duration) {
    elem.style.left = ((time - startTime) / duration * endPos % endPos) + 'px';   
  }
}
							</code>
						</pre> -->
					</div>
					
						

					<aside class="notes">
						You can also get a start time and continue the animation until a certain amount of progress has happened if you want to have time based animations, or wrap it in a settimeout with the timing set as 1000/desiredFramerate
						If there's just one "complex" anim in a project (simple button hovers and shit but one rotating gradient), just roll your own JS animation
						However, if you have more than a handful of these, really really consider using a library.
					</aside>
				</section>

				<section>
					<h1>Performance is more than properties</h1>
					
					<aside class="notes">
						<p>Just talking 2 easy things to have a big impact</p>
						<p>JS performance could be a whole talk in and of itself</p>
						<p>Remember how I said JS animation isn't janky, shitty JS animation is janky?</p>
						<p>Theres some easy tips to improve your JS performance</p>
						<p>As long as we're here, lets Not just talk anims, but also w/ events that trigger anims</p>
						
					</aside>
				</section>

				<section>
					<h1>Don't thrash</h1>
					<div class="stack">
						<pre class="stack__item">
							<code class="javascript fragment">
var h1 = element1.clientHeight;           // Read (measures the element)
element1.style.height = (h1 * 2) + 'px';  // Write (invalidates current layout)

var h2 = element2.clientHeight;           // Read (measure again, so must trigger layout)
element2.style.height = (h1 * 2) + 'px';  // Write (invalidates current layout)

var h3 = element3.clientHeight;           // Read (measure again, so must trigger layout)
element3.style.height = (h3 * 2) + 'px';  // Write (invalidates current layout)
							</code>
						</pre>

						<pre class="stack__item">
							<code class="javascript fragment">
// Readenzie
var h1 = element1.clientHeight; 
var h2 = element2.clientHeight; 
var h3 = element3.clientHeight; 

// Writenzie
element1.style.height = (h1 * 2) + 'px';
element2.style.height = (h1 * 2) + 'px';
element3.style.height = (h3 * 2) + 'px';
							</code>
						</pre>
					</div>
					<aside class="notes">
						<p>especially bad w/ jQuery. Makes it so easy to read and write to the dom, that people do it willy nilly w/o regard for performance</p>
						Credit Wilson Page http://wilsonpage.co.uk/preventing-layout-thrashing/
						be mindful of layout in JS too, CSS often triggered by JS

						Problem is, nobody actually writes code this way. Segue into workflow/library shit?
						You can use something like fastdom, or a dedicated anim library that includes batching as a performance enhancer
					</aside>
				</section>

				<!-- <section>
					<h1>Bind events as close to target as possible</h1>
					
					<aside class="notes">
						<p>See this a lot when you're having interactions on an element that isn't there when page loads, like a confirm button on form or something</p>
						<p>Binding to document preempts all input until the event fires.</p>
						<p>Especially important with touch or scroll listeners.</p>

						Basically if you do 
						https://www.youtube.com/watch?v=YyQYhhy1dZI  ~23:00
					</aside>
				</section> -->

				<section>
					<h1>Debounce</h1>
					<div class="stack">
						<pre>
							<code class="javascript" style="min-height: 28em;">
var debounce = function(func, wait, immediate) {
  var timeout, result;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) result = func.apply(context, args);
    return result;
  };
};

window.addEventListener('scroll', function(){
	debounce(function(){
		//cool animation
	},100)
},false)
							</code>
						</pre>
					</div>
					<aside class="notes">
						Debouncing is a fancy pants way to say limit a function from firing too many damn times.
						Especially important when binding to resize or scroll.
						Why fire a function more times than the browser can even refresh?

						This belongs in JS section
					</aside>
				</section>

				<!-- <section>
					<h1>Cache = $$$</h1>
					<div class="stack">
						<pre class="stack__item">
							<code class="javascript fragment">
for(var i = 0; i < $('.herp').length; i++) {
	$('.herp').index(i).css('background','rgb(0,'+i*5+',0,)');
	$('.derp').index(i).text('this is derp number '+i+1)
}
							</code>
						</pre>

						<pre class="stack__item">
							<code class="javascript fragment">
var $herp = $('.herp');
var $derp = $('.derp');
for(var i = 0, l = $herp.length; i < l; i++) {
	$herp.index(i).css('background','rgb(0,'+i*5+',0,)');
	$derp.index(i).text('this is derp number '+i+1)
}
							</code>
						</pre>
					</div>
					<aside class="notes">
						This is a basic JS thing you can do to make code mor efficient
						the performance gains from caching increase as the loops iterations increase
					</aside>
				</section> -->

				

				<section>
					<h1>Lets talk workflow</h1>
					<pre class="fragment">
						<code class="css" style="min-height: 23em;">
.logo {
	animation: myAnimation 2s linear forwards;
}
@keyframes myAnimation {
  0% {
    opacity: 0;
    transform: scale(0, 0);
  }
  25% {
    opacity: 1;
    transform: scale(1, 1);
  }
  50% {
    transform: translate(0px, 0);
  }
  100% {
    transform: translate(100px, 0);
  }
}
						</code>
					</pre>

					<p class="fragment">So what happens when somebody wants the translate to take an extra 400ms?</p>
					
					<!-- <div class="translate"></div> -->
					<aside class="notes"></aside>
				</section>

				<section data-background="img/blinds.gif">
					<h2 class="fragment">This, basically.</h2>
					<aside class="notes">
						<p>You have to add 400ms to the duration and go back and recalc all the percentages relative to the new time and agh</p>
						<p>It sucks, we've all had to do it, but it doesn't have to be this way</p>
					</aside>
				</section>

				<section>
					<h1>donde esta la biblioteca</h1>
					<h2 class="fragment">Velocity</h2>
					<h2 class="fragment">Greensock/GSAP</h2>
					<aside class="notes">
						<p>Managing CSS keyframes, especially when they get complex, can be hard, it can be time consuming.</p>
						<p>Impedes experimentation.</p>
						And in the end, when you want to get creative, CSS animation is limiting(no independent transforms, different steps with different easing etc)
					</aside>
				</section>

				<section>
					<h1>Lib your life.</h1>
					<div class="stack">
					<pre class="stack__item fragment" style="font-size: .45em">
						<code class="css">
.logo {
	animation: myAnimation 2s linear forwards;
}
@keyframes myAnimation {
  0% {
    opacity: 0;
    transform: scale(0, 0);
  }
  25% {
    opacity: 1;
    transform: scale(1, 1);
  }
  50% {
    transform: translate(0px, 0);
  }
  100% {
    transform: translate(100px, 0);
  }
}
						</code>
					</pre>

					<pre class="stack__item fragment" style="font-size: .45em">
						<code class="javascript">
var el = document.getElementsByClassName('logo')

Velocity(el, {
    opacity: [1, 0],
    scale:[1, 0]
  },{
    duration:500,
    easing: "linear"
  }
);
Velocity(el, {
    translateY: '100px'
  },{
    duration:1000,
    delay:500,
    easing: "linear"
  }
);
						</code>
					</pre>

					<pre class="stack__item fragment" style="font-size: .45em">
						<code class="javascript">
var el = document.getElementsByClassName('logo')

TweenLite.fromTo(el, .5, {
    opacity:0,
    scale:0,
    ease:"Linear.easeNone"
  },{
    opacity:1,
    scale:1,
    ease:"Linear.easeNone",
    onComplete: function(){
      TweenLite.to(el, 1, {
        delay:.5,
        y:100,
        ease:"Linear.easeNone"
      });
    }
  }
);
						</code>
					</pre>
					</div><!--end stack-->
					<aside class="notes">
						<p>Expressed in terms of time, not percents more intutive</p>
						<p>Performing multi anims on 1 element is easy, b/c instead of writing 1 super complex keyframes, you can just chain velocity or GSAP calls (come in, drop down)</p>
						<p>Both of these examples show how you can feed in start values for the element different from its resting CSS which can be useful</p>


						<p>Easier than wrangling with keyframes, and yeah, probably easier than rolling your own RAF loops.</p>
					</aside>
				</section>

				<!-- <section>
					<h1>Another example</h1>
					<div class="stack">
					<pre class="stack__item fragment current-visible">
						<code class="css">
//independent transforms example
var target = document.getElementsByClassName('.js-ind-trans-target')[0];
var rotation = 0;

TweenMax.to(target,1.2, {scale:1.2, force3D:true, yoyo:true, repeat:-1, ease:Power1.easeInOut});

target.on('click',function(){
	rotation += 360;
	TweenMax.to(target, 2, {rotation: rotation, ease:Elastic.easeOut})
});
						</code>
					</pre>

					<pre class="stack__item fragment current-visible">
						<code class="javascript">
//physics example
var target = $('.js-boing-target');
target.on('click',function(){
	target.velocity({translateY: -200},600,[500,15]).velocity("reverse")
})
						</code>
					</pre>

					</div>
					<aside class="notes">
						Libraries make the type of rapid changes and experimentation ESSENTIAL to creating good animations totally trivial.
						Easier than wrangling with keyframes, and yeah, probably easier than rolling your own RAF loops.
						Libraries make for an easier workflow. This is SO important.
					</aside>
				</section> -->

				<section>
					<h1>Other nice-to-haves</h1>
					<h3 class="fragment">Reverse / yoyo</h3>
					<h3 class="fragment">Sequencing</h3>
					<h3 class="fragment">Granular control</h3>
					<h3 class="fragment">TweenLite.from</h3>
					<aside class="notes">
						<p>R/yy makes it super easy to go back to the original position, w/ CSS you have to make the anim go to 50%, and build it back to orig yourself, its unintuitive</p>
						<p>Sequencing: instead of specifying a huge keyframes you can just chain anims together. If you want to change one, you can change the ONE. Doesn't screw up the maths for the whole thing</p>
						<p>Last two only GSAP</p>
						<p>If you're making a super super complex animation(10+ seconds long), storing it in a timeline means you can scrub to different parts to experiment, rather than waiting until the end every time you iterate</p>
						<p>Allows you to easily breathe life into static elements</p>
					</aside>
				</section>

				<section>
					<h1 class="fragment fade-out">Workflow is important</h1>
					<h1 class="fragment">Easier changes</h1>
					<h1 class="fragment">More experimentation</h1>
					<h1 class="fragment">Better work</h1>
					<aside class="notes">
						<p>Animation by its very nature is iterative and experimental</p>
					</aside>
				</section>

				<section>
					<h1>Performance</h1>
					<h3 class="fragment">Global timing loop for all animations</h3>
					<h3 class="fragment">Minimizes layout thrash</h3>
					<h3 class="fragment">Won't animate anything visually imperceptible</h3>
					<aside class="notes">
						<p>1) too many timers firing at once reduces frame rates due to the browser’s overhead of maintaining them</p>
						<p>2) improperly marking the time at which your animation begins results in dropped frames (usually you have the animation start when you click the button, but due to a myriad of factors like CPU overhead, other JS logic at the same time, etc) can cause a delay in when you start to see the anim, dropping early frames.</p>

						<p>Caching property values across chained calls in order to minimize the occurrence of DOM querying (which is the Achilles' heel of performant DOM animation).</p>
						<p>Caching unit conversion ratios (e.g. px to %, em, etc.) across sibling elements in the same call.</p>

						<p>Kind of like a debounce, function only runs when nec. Skipping style updating when updates would be visually imperceptible.</p>

						<p>You could write these optimizations into your own hand crafted animation code, but then A. your code becomes harder to manage, and B. you end up creating an animation library yourself.</p>
					</aside>
				</section>

				<section>
					<h1>Another dependency</h1>
					<h1 class="fragment">le UGH!</h1>
					<aside class="notes">
						Velocity ~35kb
						TweenLite & CSSPlugin ~60kb
					</aside>
				</section>

				<section>
					<h1>Don't be a stupid.</h1>
					<h1 class="fragment">Weigh the costs and benefits.</h1>
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1>le OMG I love libraries</h1>
					<h1 class="fragment">Which one is raddest?</h1>
					<aside class="notes">
						
					</aside>
				</section>

				<section>
					<h1>Greensock</h1>
					<h2 class="fragment">More options and capabilites</h2>
					<h2 class="fragment">Insane timlineing and control</h2>
					<h2 class="fragment">A tad better performance</h2>
					<h2 class="fragment">Big KB hit</h2>
					<h2 class="fragment">Licensing</h2>
					<h2 class="fragment">Best for 1 pagers, rich motion design, webGL/canvas/games/experiments</h2>
					<aside class="notes">
						<p>It can do more. A lot more. It can tween any property of any javascrpit object. BIG distinction. Means that it's not just for UI animation, but for WebGL, canvas, games, and other shit my puny human brain can't even dream up</p>
						<p>Timlining both good for workflow and make it easier to have animations overlap, sequence, etc</p>
						<p>I'm unsure as to why, but it performs a smidge better than velocity in ultra high stress situations</p>
						<p>TweenLite & CSSPlugin ~60kb</p>
						<p>Have to pay to use it in a product</p>
						<p>For the fun and the frivolous</p>
					</aside>
				</section>

				<section>
					<h1>Velocity</h1>
					<h2 class="fragment">UI only</h2>
					<h2 class="fragment">Lighter KB hit</h2>
					<h2 class="fragment">More approachable API</h2>
					<h2 class="fragment">Same syntax as jQuery</h2>
					<h2 class="fragment">100% open source & free</h2>
					<h2 class="fragment">Plays extra well with promises</h2>
					<h2 class="fragment">Best for UI animation in applications</h2>
					<aside class="notes">
						<p>It's a UI animation tool, well suited for it, and w/o the bloat/features of GSAP</p>
						<p>~30kb, all in</p>
						<p>At least to me, it makes a bit more sense. Take sequencing for example, you just follow it with another .velocity, don't need to mess around w/ callbacks</p>
						<p>this is huge. The examples we showed thusfar was to how to use velocity w/o jquery. However, if you use jquery you can literally just include velocity, and do a find/replace for .animate, and you've gotten a massive, free performance boost</p>
						<p>Julian is a great guy, loves PRs, easy to get involved in community</p>
						<p>Each velocity call returns a promise object</p>
					</aside>
				</section>

				<section>
					<h1>TLDR:</h1>
					<!-- <h2 class="fragment">Use CSS for simple state changes</h2> -->
					<h2 class="fragment">Be aware of how your code impacts browser rendering</h2>
					<h2 class="fragment">Test render performance as you work</h2>
					<h2 class="fragment">Avoid $.animate and setInterval</h2>
					<h2 class="fragment">Debounce & don't thrash</h2>
					<h2 class="fragment">JS libs make sense in a certain set of circumstances</h2>
					<aside class="notes">
						<p>Conclusion</p>
					</aside>
				</section>

				<section>
					<span class="fragment js-thanks"></span>
					<svg class="thanks" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 413.3 209.7" enable-background="new 0 0 413.3 209.7" xml:space="preserve">
						<path class="t__stick" fill="none" stroke="#000000" stroke-miterlimit="10" d="M35.7,118.7c0,0-0.3,20,10,20s22.2-14.5,23.7-17.3
							c6-11.1,8.3-14.7,11-20.3c5.2-10.8,6.3-24.2,14-34c6.8-8.6,13.3-16.3,13.3-16.3"/>
						<!-- <path fill="none" stroke="#000000" stroke-miterlimit="10" d="M0,209.7"/> -->
						<path class="hanks" fill="none" stroke="#000000" stroke-miterlimit="10" d="M83.3,129c0,0,46.3-26.7,87.3-96.7s-17.1-6.6-24,19
							C139.8,77,116,124.7,116,124.7s30.7-40,34.7-35.7c4,4.3-5,19-5.3,26c-0.3,7,4,17.3,16.7,4.3s20.6-30.3,28.1-27.7
							c7.5,2.7,2.5,13,2.5,13s2.2-14.3-4.7-11.5s-26.2,26.7-15.8,27.5c10.3,0.8,22.1-16,22.1-16s-4.4,18.8,2.3,17.3s24.1-27,26.1-27.7
							c2-0.7,8.2-1.7,0.7,14.7s-8,18.8-8,18.8s18-24.5,25-23.2s-6.2,13.3-6.2,17s0.8,11.2,16,4s24.5-15.5,49.2-50
							c24.7-34.5,16.2-46.5,5.3-30.5c-10.8,16-25.5,59.7-31.2,70s-13.8,25.3-13.8,25.3s18.2-45.7,40.8-47.7s10.3,19,4.5,20.3
							s-10.3,4.5-26.5-1.3c0,0,10.2,0.7,19.3,17.7c9.2,17,24.3-9.5,32.7-14.7c8.3-5.2,19.7-17.3,15.8-20.3c-3.8-3-8.3-3.3-8.2,9.8
							c0.2,13.2,7.2,29.7-0.3,31.8c-7.5,2.2-14.3-3-18.2-8c0,0,13.7,23,45.2,3"/>
						<path class="t__hat" fill="none" stroke="#000000" stroke-miterlimit="10" d="M158.3,15.7c0,0-13.2,15.5-70.5,23.8s-46.3,60-27.8,47.8
							s31.3-34.8,31.3-34.8"/>
						<!--<path fill="none" stroke="#000000" stroke-miterlimit="10" d="M387.7,121.1c5.2-10.8,17.6-83.2,25.2-93"/>-->
						<path class="expl__stroke" fill="none" stroke="#000000" stroke-miterlimit="10" d="M411.7,27.8c-5,11-15.4,83.7-22.8,93.6"/>
						<path class="expl__dot" fill="none" stroke="#000000" stroke-miterlimit="10" d="M387.7,136.3c-3.1-11.6-0.5,7.5-1-4.9"/>
						<path class="underline" fill="none" stroke="#000000" stroke-miterlimit="10" d="M28.2,172c44.3,8.1,322.7-13.5,364.8,3.6"/>
					</svg>

					<aside class="notes">
					</aside>
				</section>

				

			</div>

		</div>

		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
		<script src="js/velocity.min.js"></script>
		<script src="js/blast.min.js"></script>
		<!--<script src="js/tweenlite.min.js"></script>
		<script src="js/gsap-css-plugin.min.js"></script>-->
		<script src="js/tweenmax.min.js"></script>


		<script src="js/app.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: false,
				history: true,
				center: true,
				width: 1200,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
